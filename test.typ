#import "@local/ysz_tools:0.1.0": *

#show: conf.with(
  title: " OS note",
  author: "kiwiizzz & xhkzdepatedream",
)

= 前言：什么是操作系统？

操作系统是一种系统软件，主要功能是：
- 向下管理 CPU、内存和各种外设等硬件资源；
- 形成软件执行环境来向上管理和服务应用软件。
== 系统调用接口
操作系统与运行在用户态软件之间的接口，形式就是上一节提到的应用程序二进制接口 (ABI, Application Binary Interface)。

系统调用（System Call）：

操作系统提供的、唯一合法的“用户 → 内核”入口


用户态发起系统调用，CPU 切换到内核态，OS 执行服务，返回用户态继续执行

系统调用 = 安全受控的越权通道

应用程序最常见的需求：输入 / 输出，内存申请，文件持久化，设备访问，多程序并发，进程 / 线程管理，全部通过系统调用完成。


操作系统并不是“直接暴露硬件”，而是 抽象 + 虚拟化：
#tablem[
  | 抽象概念         | 抽象了什么    |
| ------------ | -------- |
| 文件 (File)    | 外设 / 存储  |
| 地址空间         | 内存       |
| 进程 (Process) | CPU + 资源 |
| 线程 (Thread)  | 执行流      |]

感觉这个表格丑丑的。

== 操作系统抽象
=== 执行环境
一个程序运行时所依赖的服务集合、资源管理规则、权限边界，它决定了程序能做什么、不能做什么，以及程序的生命周期如何被管理。

应用程序只能看到执行环境提供的接口，看不到下面一层。
例如：应用程序->函数库->操作系统内核->硬件
OS 统一管理CPU/内存/设备。函数库通过系统调用向 OS 要资源。

=== 控制流上下文（执行环境的状态）
为了让控制流“下一条指令还能正确执行”，必须被保存的一切状态。

例如：程序计数器（PC）、栈指针（SP）、通用寄存器（a0–a7 / t0–t6 / s0–s11 等）、特权级相关寄存器、页表基址（地址空间）

异常控制流（ECF）：中断 / 异常 / 陷入不必多说。

=== 进程
对应用程序而言：它觉得自己拥有连续的内存地址空间和专属的 CPU。

对操作系统而言：通过快速切换和内存映射，让成百上千个进程在有限的硬件上共存。

为了提高处理器的利用率，操作系统需要让处理器足够忙，即让不同的程序轮流占用处理器来运行。如果一个程序因某个事件而不能运行下去时，就通过进程上下文切换把处理器占用权转交给另一个可运行程序。

#image("assets/进程上下文切换.png", width: 50%)

=== 地址空间
其实是虚拟内存。标准定义如下：
#definition(title: "地址空间")[
地址空间 (Address Space) 是对物理内存的虚拟化和抽象，也称虚存 (Virtual Memory)。它就是操作系统通过处理器中的内存管理单元(MMU, Memory Management Unit) 硬件的支持而给应用程序和用户提供一个大的（可能超过计算机中的物理内存容量）、连续的（连续的地址空间编址）、私有的（其他应用程序无法破坏）的存储空间。
]

=== 文件
外设可以通过文件进行统一的抽象，并在操作系统内部实现中来隐藏对外设的具体访问过程，从而让用户可以以统一的文件操作来访问各种外设。应用程序通过基本的读写操作来完成对外设的访问。

== 操作系统的特征
一共五个，感觉看一两眼就知道是什么了，不太难，交给ysz


#pagebreak()

